            ------------Создаем фильтр мата--------

Пишем его в общей части бота.

------------------------------------
--создадим фильтр мата.вначале нам нужно сформировать базу мата и создать файл json: ---

Создаем текстовый документ (пусть будет cenz_cosmetiks.txt),в который добавляем 
слова для фильтра (каждое слово с нового абзаца),далее запускаем отдельный файлик 
to_json.py и в нем преобразуем txt файл в json файл cenz_cosmetiks.json,

Код файла to_json.py:
	import json

	ar = []

	with open('cenz_cosmetiks.txt',encoding='utf-8') as r:
    		for i in r:
        		n = i.lower().split('\n')[0]
        		if n != '':
            			ar.append(n)
	with open('cenz_cosmetiks.json','w', encoding = 'utf-8') as e:
    		json.dump(ar, e)

(------Описание внутри файла для преобразования в json-----
импортируем модуль json,создаем пустой список ar,открываем для чтения 
наш текстовый документ cenz_cosmetiks.txt в кодировке utf-8.Проходимся построчно циклом 
for(т.е читаем информацию из дока,переводим на всякий случай все в нижний регистр(с помощью 
lover),разбиваем(с помощьюс split) по разделителю (перенос строки \n).Т.к там в строке есть 
знак абзаца,то получаются списки из слова и служебного символа абзаца.Берем по индексу 0 это 
слово,проверяем что бы там не была пустая строка и добавляем в список ar.'''
'''открываем на запись(сам создастся) файл с расширением json (cenz_cosmetiks.json),открываем 
его для чтения ('w'),в кодировке utf-8.Используем из модуля json ф-ию .dump(позволяет записать 
данные в json файл),передаем туда первый аргумент(наш список из слов ar),второй агрумент(сам объект чтения e)'''
------------------------------------

Импортируем модуль json в файл bot_telegram_cosmetiks.py .

Начинаем писать сам фильтр(не путать с фильтроми в aiogram).

Создаем хендлер:
	@dp.message_handler()
	async def echo_send_mat(message : types.Message):

вначале(т.к любые сообщения,которые попадают в нашу группу,попадают в хендлер т.к в нем не указано аргументов в ())
нужно сделать простую проверку.Нам нужен генератор множест(записываем простую конструкцию for i in,берем событие(сообщение message,
которое пользователь отправил),берем из него текст text и проходимся по нему.Нужно разбить его по разделителям(в данном случаем,разде-
лителем будет пробел ' ') с помощью .split.
	for i in message.text.split(' ')

Теперь в i будут попадать слова без пробелов).Теперь формируем множество{} (т.е обрабатываем то,что попадает в i)(записываем перед for) : 
переводим все i в нижний регистр (lower)
	{i.lower(). for i in message.text.split(' ')}

теперь необходимо очистить слова от маскирующих символов(маскируют через !,% и т.д),используем метод списков .translate,в который нужно 
передать макет изменений для замены символов в строке(он находится:обращаемся к типу данных строка str и пишем его метод maketrans(),в 
который нужно передать 3 аргумента: (1)что менять(записываем пустую строку ''), 2)на что менять(записываем пустую строку ''), 3)символы 
из строки,которые нужно убрать(перечислять все не будем,возьмем из модуля string(нужно импортировать в файл).
	import string
Там есть готовый из знаков пунктуации punctuation)).
	if {i.lower().translate(str.maketrans('', '', string.punctuation)) for i in message.text.split(' ')}:

теперь у нас есть файл cenz_cosmetiks.json, нужно реализовать проверку есть ли в сообщении пользователя слова из файл json,т.е нужно сравнить два
огромных списка.Используем множетсва,т.к они работают очень быстро и есть метод пересечения множест intersection(позволяет быстро сравнить
есть ли совпадения).Внутри него как аргумент формируем новое множество,читая данные из нашего json файла
знак \ можно использовать для переноса строки
	
	@dp.message_handler()
	async def echo_send_mat(message : types.Message):
    		if {i.lower().translate(str.maketrans('', '', string.punctuation)) for i in message.text.split(' ')}\
        		.intersection()

как аргумент записываем set(формируем новое множество),используем библиотеку json,метод load (позволяет прочитать данные из файла),в него 
передаем объект чтения(грубо говоря функцией open читаем файл 'cenz_cosmetiks.json')).

	@dp.message_handler()
	async def echo_send_mat(message : types.Message):
    		if {i.lower().translate(str.maketrans('', '', string.punctuation)) for i in message.text.split(' ')}\
        		.intersection(set(json.load(open("cenz_cosmetiks.json"))))

Эта проверка возвращает в i пересечение множеств из сообщения и множества из json файла.Т.е если совпадений нет-вернется пустое множество.Поэтому 
записываем != set(),т.е если оно не пустое,значит есть мат.

	@dp.message_handler()
	async def echo_send_mat(message : types.Message):
    		if {i.lower().translate(str.maketrans('', '', string.punctuation)) for i in message.text.split(' ')}\
        		.intersection(set(json.load(open("cenz_cosmetiks.json")))) != set():

Записываем await message.reply('маты запрещены') и удаляем сообщение await message.delete()

	@dp.message_handler()
	async def echo_send_mat(message : types.Message):
    		if {i.lower().translate(str.maketrans('', '', string.punctuation)) for i in message.text.split(' ')}\
        		.intersection(set(json.load(open("cenz_cosmetiks.json")))) != set():
        		await message.reply('maty zapreszeny')
        		await message.delete()

Теперь запускаем бота и при вводе мата он будет удалять сообщение пользователя и присылать сообщение.

--------------------------------------------
Если мы хотим обратиться к пользователю по имени,можем достать его имя через объект User:
	user = message.from_user 

достаем имя пользователя через .first_name
	user.first_name
--------------------------------------------






